---
title: Análisis de las condiciones favorables para la ocurrencia de incendios en el
  Perú para los años 2000 -2018
author: "Contreras y Flores"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    fig_caption: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
---

# Introducción
Los incendios forestales se han convertido en un problema ambiental de gran relevancia y gravedad en las últimas décadas; se presenta a nivel mundial sobre todo en los países con grandes extensiones de áreas forestales (Sabuco, 2013) como es el caso del Perú (FAO, 2004). 
El impacto de los incendios reduce la tasa de crecimiento de los bosques, genera muerte y migración de la fauna silvestre, pérdida de la biodiversidad, trasformación de los suelos e incremento de la erosión, contaminación del aire, reducción de servicios de regulación hídrica del ecosistema, mayor incidencia en derrumbes e inundaciones, incluso la aparición de plagas y enfermedades en los bosques debilitados por dichos incendios. (MINAM, 2019)
En este análisis se evaluará la estacionalidad de las variables bioclimáticas que favorecen a la ocurrencia de incendios.

## 1. Identificación del problema

En los últimos años los incendios han impactado severamente varias regiones del Perú, como Cusco, Lambayeque, Piura y
Cajamarca (INDECI, 2013; El Comercio, 2018), siendo muy perjudicial para un Perú que no está en condiciones de afrontar este tipo de emergencias al no tener una unidad especializada de respuesta ante Incendios (RPP, 2016). 

### 1.1. Planteamiento del problema
### 1.2. Objetivos
#### 1.2.1. Objetivo General
Analizar la estacionalidad de variables bioclimáticas en el marco del estudio de las condiciones favorables para la ocurrencia de incendios (CFOI).

#### 1.2.2. Objetivos Específicos
* Analizar las variables climáticas (calidad de vegatción, temperatura y preciptación) de forma interestacional en las zonas CFOI
* Analizar el comportamiento estacional de las variables bioclimáticas con respecto a la altitud en las zonas CFOI.

### 1.3. Justificación
Las graves consecuencias que a todos los niveles (ecológico, económico, social y humano) pueden derivarse de un incendio forestal son razones suficientes para dedicar una atención especial a este fenómeno. El hombre ha desarrollado numerosos instrumentos y puesto en práctica diversos procedimientos para combatirlos. 
Este proyecto de investigación se justifica en la carencia de datos estadísticos relacionados al registro histórico de incendios y su distribución espacial, así como su relación con las condiciones favorables que se encuentran presentes en el momento de la aparición del incendio, aspecto que debe ser la base para el entendimiento de este fenómeno y de la generación de las políticas de Estado para atenderlo, desde una óptica de prevención y reducción del riesgo.

## 2. Antecedentes

[MONITOREO DE LAS CONDICIONES FAVORABLES PARA LA OCURRENCIA DE INCENDIOS SOBRE LA COBERTURA VEGETAL – CFOI](https://repositoriodigital.minam.gob.pe/bitstream/handle/123456789/652/Monitoreo-CFOI_CV.pdf?sequence=1&isAllowed=y)

[Ocurrencia de incendios forestales en el Perú durante eventos El Niño](https://repositorio.igp.gob.pe/bitstream/handle/20.500.12816/4704/Zubieta_etal_2019_Ocurrencia-de-incendios-forestales-en-el-Peru-durante-eventos-El-Nino.pdf?sequence=1&isAllowed=y)

[Uso de estimados de densidad Kernell en  la investigación de grupos cerámicos del Periodo Formativo provenientes de Chavín de Huantar](https://revistasinvestigacion.unmsm.edu.pe/index.php/Arqueo/article/view/12339/11039)  


[Estadística no paramétrica I - youtube](https://www.youtube.com/watch?v=Q40ESwQbJO8)  


## 3. Marco Teórico

### 3.1 Función Kernel

* Aveces, el Kernel es una funcion de ventana (window function)
* Una window function fuera de cierto intervalo adopta el valor 0 
* Un kernel, a su vez, es una funcion no negativa (no dijimos qué forma
aun)
* Usaremos un parametro de suavizacion o bandwidth (h) -més alto, mas
suavizamos.

Estimación de la densidad para un punto $x$ :

$${\displaystyle {\widehat {f}}_{h}(x)={\frac {1}{n}}\sum _{i=1}^{n}K_{h}(x-x_{i})={\frac {1}{nh}}\sum _{i=1}^{n}K{\Big (}{\frac {x-x_{i}}{h}}{\Big )}}$$
Donde

* $n:$ Número de observaciones (cada datos es el centro donde se coloca el kernel).
* $h:$ Ancho de banda.
* $K:$ Es la función kernel.


## 4. Área de estudio

## 5. Metodología
Nuestra metodología se resume en cuatro principales etapas, tal y como se describe en la siguiente figura:

```{r echo = FALSE, fig.align='center', comment='Figura 1. Metodología del Trabajo.'}
knitr::include_graphics('Img/metodologia_4etapas.jpg')
```

### Librerias de R utilizadas hasta el momento

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(sf)
library(rgee)
library(mapedit)
library(raster)
library(cptcity)
library(leaflet)
library(leaflet.extras)
library(leafpop)
library(MASS)
library(dplyr)
library(tidyverse)
library(rgee)
```

```{r , eval=TRUE, echo=FALSE}
# Inicializando sesion en GEE
ee_Initialize('juliocontreras1', drive =TRUE)
```

### 5.1 Localización del área de estudio

#### 5.1.1 Histograma de la acumulación de incendios a lo largo del tiempo

```{r, eval=TRUE, message=FALSE, echo = FALSE, warning=FALSE, cache=FALSE, fig.align='center', comment='Figura 1. Metodología del Trabajo.'}
# Incendios acumulados por mes
shp   <- 'Materiales/registro_incendios_2000_2018.gpkg'
fires <- st_read(shp) %>% 
  mutate(Date = paste(`AñO`, 
                      MES_N, 1, 
                      sep = '-')) %>% 
  group_by(Date) %>% 
  summarise(nfires = length(Date)) %>% 
  mutate(Date = as.Date(Date)) %>%
  arrange(Date) %>% 
  as.data.frame() %>%
  dplyr::select(-geom)
# Como no todos los meses hay incendios se necesita tener todos los meses para generar el histograma
ts    <- data.frame(Date = seq(as.Date('2000-08-01'), 
                               as.Date('2018-12-01'), 
                               by = 'month')) %>% 
  full_join(fires) 

# Generación del histograma

X <- ggplot(ts, aes(x=Date, y=nfires)) + 
  geom_bar(stat="identity", 
           fill="gray", 
           colour="black") +
  theme_bw() + 
  ylab(label = 'Número de incendios\n') +  
  xlab(label = '') + 
  ggtitle(paste('Eventos de incendios \ndel año 2000 al 2018', sep = '')) +
  theme(plot.title = element_text(hjust = 0.5, face = 'bold', size=15),
        axis.text.x  = element_text(size=11, angle = 75, hjust = 1),
        axis.text.y  = element_text(size=11),
        axis.title.y = element_text(size = 12, hjust = 0.5, face = 'bold', vjust = 0.5)) + 
  scale_x_date(limits = c(as.Date('2000-07-01'),
                          as.Date('2019-01-01')),
               date_labels = ("%Y"), 
               breaks = '1 year') +
  scale_y_continuous(breaks = seq(0,500,50))
X

```
Dos de eventos de los que vamos a inspeccionar coinciden con eventos extremos, en un estudio realizado por el [Senahmi](https://bit.ly/3hX0K8a), se determinó que el año 2005 y 2016, ocurrieron grandes sequías en las zonas altoandinas, para ello se utilizó el índice estandarizado de precipitación (SPI). El año 2010, tiene también un relativo SPI negativo, pero no llega a niveles extremos como en los años mencionados. Además, mencionamos que el 2004 es el año con mayor SPI, en el rango de los años de estudio, pero las sequías evidenciadas en este año se dieron durante la fase neutra del ENOS. En los demás años (7) de sequías extremas pertenecieron a la fase cálida del El Niño Oscilación Sur (ENOS).

#### 5.1.2 Histograma de la acumulación de incendios a lo largo del tiempo

```{r, eval=TRUE, message=FALSE, echo = FALSE, warning=FALSE, cache=FALSE, fig.align='center', comment='Figura 1. Metodología del Trabajo.'}
# Incendios acumulados por mes
shp   <- 'Materiales/registro_incendios_2000_2018.gpkg'
fires <- st_read(shp) %>% 
  mutate(Date = paste(`AñO`), Fecha = paste(`AñO`, MES_N, DIA, sep = '-')) %>% 
  as.data.frame() %>%
  dplyr::select(Date, Fecha, LOCALIDAD, 
                DES_EMERGE, DES_FUENTE, DES_DANO, 
                NOMBDIST, NOMBPROV, NOMBDEP, COOR_X, COOR_Y, -geom)
names(fires) <- c("Date", "Fecha", "Localidad", 
                  "Causa", "Acción", "Daños",
                  "Distrito", "Provincia", "Departamento", "Longitud", "Latitud")

# Este es más dinámico
Number_JmType <- fires$Date %>% unique() %>% length() # Numero de especies
Names_JmType <- fires$Date %>% unique() ## Nombre de las especies
Colores <- c("#ef3b2c", "#ffffff", "#807dba", "#33a02c", "#fed976", 
             "#000000", "#0570b0", "#a6cee3", "#1f78b4", "#b2df8a",
             "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00",
             "#cab2d6", "#6a3d9a", "#b15928") # colorbrewer2, Colores de las especies seran
pal <- colorFactor(Colores, domain = Names_JmType) # Generamos la paleta


# Partimos un sf en varios sf
Spp_Pres <- list()
for (i in 1:length(Names_JmType)) {
  Spp_Pres[[i]] <- fires %>% dplyr::filter(Date == Names_JmType[i])
}
names(Spp_Pres) <- Names_JmType

# Ploteamos cada sf, pero sin leyenda
Spp_Map <- leaflet() %>% addTiles(urlTemplate = "https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png") %>%
  addPolygons(data = Departamentos,
              fillOpacity = 0,
              weight = 1,
              opacity = 1,
              label = ~DEPARTAMEN,
              color = "#ef3b2c",
              group = "Departamentos")
for (i in 1:length(Spp_Pres)) {
  Spp_Map <- Spp_Map %>%
    addCircleMarkers(data = Spp_Pres[[i]],
                     lat = ~Latitud, lng = ~Longitud, fillColor = ~pal(Date),
                     fillOpacity = 0.8, radius = 6, weight = 0.5, label = ~Provincia,
                     color = ~pal(Date), group =  Names_JmType[i], 
                     popup = popupTable((Spp_Pres[[i]])[,2:length(Spp_Pres[[i]])],
                                        row.numbers = F, feature.id = F))
}


# Agremos leyenda y su visualizador por grupos, tanto leyenda como suelos
Spp_Map <- Spp_Map %>%
  addLegend(data = fires, "bottomleft", pal = pal, 
                values = ~Date, title = "Inc: 2000-2018", 
                opacity = 0.8, group = "Leyenda") %>%
  addLayersControl(overlayGroups = c("Leyenda"), baseGroups = Names_JmType,
                   options = layersControlOptions(collapsed = FALSE), position = "topright")
Spp_Map

```


#### 5.1.3 Estimación de densidad de probabilidad 2D: función de densidad no paramétrica

Se tratade suvizar una serie tanto en el eje x e y. Seria raro que pase un incendio en un lugar y no haya la probabilidad que ocurra a sus alrededores cercanos, mientras que a unos cuantos metros paso uno grande.

En realidad existe funciones de densidad parámetricas, donde la función depende de la varianza o media muestral, por ejemplo, la función de probabilidad normal.

Se estima la función de densidad de probabilidad para calcular en porcentaje la posibilidad de ocurrencia de incendios para cada pixel, clusterizando las regiones con mayor probabilidad por sobre un umbral definido, además se muestra la región a partir de la cual se basará nuestros graficos de análisis posteriores.

Basicamente, esta función del paquete MASS, la función kernel varía por ubicación (asignandole peso), ese es el porqué de su argumento de coordenadas.




```{r, eval=TRUE, message=FALSE, echo = FALSE, warning=FALSE, comment=FALSE}
fires <- st_read(shp)
peru <- st_read('Materiales/Peru.gpkg')
Departamentos <- st_read('Materiales/Departamentos.gpkg')

# Extracción de coordenadas de los puntos
fires_df <- st_coordinates(fires) %>% as.data.frame()
names(fires_df) <- c('lon','lat')#here

# Aplicación de la estimación
kde <- kde2d(fires_df$lon, fires_df$lat, n = 250, h = .5, lims = c(-86, -65, -19, 0))
kde_raster <- kde %>% raster() %>% crop(peru) %>% mask(peru)

# image(kde)
# plot(peru, add = T, col = NA)

# Convirtiendolo a raster:
# 
# kde_raster <- kde %>% raster()
# kde_raster[kde_raster < 0.05] = NA
# kde_raster[kde_raster >= 0.05] = 1
# writeRaster(kde_raster, 'raster2.tif')

# summary(kde_raster %>% getValues() %>% as_vector())
# Mapa con leaflet
# pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), values(kde_raster ), na.color = "transparent")


pal <- colorNumeric(c("#3182bd", "#fec44f", "#f03b20"), values(kde_raster), na.color ="transparent")
                   

m <- leaflet() %>%
  addTiles() %>%
  addRasterImage(kde_raster, colors = pal) %>%
  addLegend(pal = pal, values = values(kde_raster),title = "% Incendios") %>%
  addPolygons(data = Departamentos,
              fillOpacity = 0,
              weight = 2,
              opacity = 1,
              label = ~DEPARTAMEN,
              color = "#000000",
              group = "Departamentos")
m
```







#### 5.1.4 Elección del área de estudio

```{r, eval=TRUE, message=FALSE, echo = FALSE, warning=FALSE, cache=FALSE}
Provincias <- st_read('Materiales/Provincias.gpkg')
Anta <- st_read('Materiales/Anta.gpkg')
names(Provincias)
kde_raster_clas <- kde_raster
kde_raster_clas[kde_raster < 0.05] = NA
kde_raster_clas[kde_raster >= 0.05] = 1
# writeRaster(kde_raster, 'raster2.tif')


leaflet() %>%
  addTiles() %>%
  addRasterImage(kde_raster_clas, 
                 colors = "#f03b20") %>%
  # addLegend(pal = pal, values = values(kde_raster),title = "% Incendios") %>%
  addPolygons(data = Provincias,
              fillOpacity = 0,
              weight = 2,
              opacity = 1,
              label = ~PROVINCIA,
              color = "#000000",
              group = "Provincias") %>%
  addPolygons(data = Anta,
              fillOpacity = 0,
              weight = 4,
              opacity = 1,
              label = ~PROVINCIA,
              color = "#54278f",
              group = "Anta")
```

#### 5.1.5 Variabilidad estacional de la ocurrecia de incendios

Se verá el comportamiento estacional promeido y máximo, para un registro de incendios 2000 - 2018.

```{r}

fires <- st_read('Materiales/registro_incendios_2000_2018.gpkg')

yr <- 2016

# CREACI?N Y MANIPULACI?N DE TABLA PARA EL PLOTEO
a <- fires %>% group_by(Date = paste(`AñO`, MES_N, sep = '-')) %>%
  summarise(nfires = length(Date)) %>% 
  group_by(MES = substr(Date,6,7)) %>% 
  summarise(fires_mean = mean(nfires, na.rm = T), fires_max  = max(nfires, na.rm = T)) %>%
  mutate(MES = as.numeric(MES)) %>% arrange(MES) %>% as.data.frame() %>% dplyr::select(-geom)

b <- fires %>% filter(`AñO`== yr) %>%
  mutate(MES = MES_N) %>%
  group_by(MES) %>% 
  summarise(fires_anom = length(MES)) %>%
  as.data.frame() %>% dplyr::select(-geom)


df <- data.frame(MES = c(1:12)) %>% 
  full_join(a, by = 'MES') %>% 
  full_join(b, by = 'MES') %>% 
  dplyr::select(-MES) %>%
  mutate(Date = seq(as.Date('2018-01-01'), as.Date('2018-12-01'), by='month'),
         fires_mean = ifelse(is.na(fires_mean), 0, fires_mean),
         fires_max  = ifelse(is.na(fires_max), 0, fires_max),
         fires_anom = ifelse(is.na(fires_anom), 0, fires_anom),
         label_mean = 'mean', label_max = 'max', label_anom = 'anom')

# CAMBIO DE IDIOMA
Sys.setlocale(category = "LC_ALL", locale = "english")

# PLOTEO  
X <- ggplot(df) +
  geom_bar(aes(x = Date, y = fires_mean, fill = label_mean),
           stat="identity", fill='blue', colour='blue', alpha=0.4) +
  geom_bar(aes(x = Date, y = fires_anom, fill = label_anom), 
           stat="identity", fill='gray', colour='black', alpha=0.4) +
  geom_bar(aes(x = Date, y = fires_max,  fill = label_max), 
           stat="identity", colour='red', alpha=0) +
  ggtitle('Comportamiento Mensual de Incendios', subtitle = paste0('Desde 2000 to 2018\nAño ', as.character(yr))) +
  theme_bw() + labs(y = 'Number of fires', x = '') +
  theme(plot.title    = element_text(size=20, hjust = 0.5, face = 'bold'),
        plot.subtitle = element_text(size=12, hjust = 0.5, face = 'italic'),
        axis.text.x   = element_text(size=12, hjust = 1),
        axis.text.y   = element_text(size=12),
        axis.title.y  = element_text(size=15, hjust = 0.5, face = 'bold', vjust = 0.5))  + #
  scale_x_date(date_labels = "%b", breaks = '1 month') +
  scale_y_continuous(breaks = seq(0,140,20), limits = c(0, 140)) +
  theme(legend.position = "none")
X

  # ggtitle(paste('Eventos de incendios \ndel año 2000 al 2018', sep = '')) +
  # theme(plot.title = element_text(hjust = 0.5, face = 'bold', size=15),
  #       axis.text.x  = element_text(size=11, angle = 75, hjust = 1),
  #       axis.text.y  = element_text(size=11),
  #       axis.title.y = element_text(size = 12, hjust = 0.5, face = 'bold', vjust = 0.5)) 
# ggsave(plot = X, filename = 'D:/DataBase/Theme_n2/04-Graphics/Bar_Fires_2016.png',
#        width = 15, height = 15, units = "cm", dpi = 500)

```


En lo gráficos generados tanto para los años 2005, 2010 y 2016, las barras con contorno rojo representan los registros máximos históricos mensuales entre el 2000 y el 2018. Las barras azules representan el número promedio de incendios mensuales y las barras grises representan el registro mensual instantaneo para los años en mención. Ahora vemos que en el año 2005 los meses en los que se supera el registro promedio mensual son julio, agosto, septiembre y noviembre, siendo julio y septiembre los que alcanzan los maximos historicos. En el año 2010, por su parte los meses de junio, agosto, septiembre, octubre y noviembre, son los que superan el promedio, siendo agosto el que alcanza el máximo histórico. Por ultimo, en le 2016, los meses de julio, agosto, septiembre y noviembre son los que superan el promedio historico, siendo septiembre y noviembre los que alcanzan los maximos históricos. En conclusion, lo meses con los más altos registros de incendios, estan comprendidos entre julio y noviembre.



### 5.2 Materiales

#### 5.2.1 Data histórica de incendios 2000-2018
Este registro abarca los años 2000 a 2018, descargados del [geoservidor del Ministerio del Ambiente (MINAM)](https://geoservidor.minam.gob.pe/monitoreo-y-evaluacion/registros-historicos-cfoi/).

#### 5.2.2 Precipitación acumulada y Temperatura Máxima
Este se obtendrá del producto grillado PISCO, del Servicio Nacional de Meteorología e Hidrología (SENHAMI)

#### 5.2.3 Índice de Vegetación Normalizado (NDVI)
Este se obtendrá del producto del sensor MODIS (MOD13Q1) del sensor Terra, 2000 - 2018. Este producto es un compuesto de 16 días, bajo el método de valor máximo, tiene una resolución espacial de 250 m

Ahora toca trabajar con las variables bioclimáticas...


Dentro del producto se tiene sub data sets, donde podemos encontrar el NDVI y EVI, y las bandas que se utilizaron para sus calculos, así mismo encontrarás la banda $qa$ o banda de calidad. La banda de calidad (qa) te muestra el estado de los píxeles, según la presencia de artefactos como las nubes, sombras, cobertura de nieve. Aquí filtraremos los datos de NDVI a través de la ***qa*** (0-65535) con una resolución radiométrica de 16 bits $2^16$.

##### Filtro por la banda de calidad
Para entender como se interpreta un banda de calidad no dirigimos a la página de [GRASS GIS](https://grass.osgeo.org/grass78/manuals/i.modis.qc.html), donde nos ofrece un descripción de la ***qa***. Tenemos que pasar nuestros ND de un sistema decimal a uno binario (ahí es donde se hace la interpretación) donde nos resultará 16 dígitos. Los códigos a continuación creará un función filtro **qa**

```{r, warning=FALSE, cache=FALSE}
# Función para los filtros con la banda quality pilxles qa
getQABits <- function(image, qa) {
  # Convert binary (character) to decimal (little endian)
  qa <- sum(2^(which(rev(unlist(strsplit(as.character(qa), "")) == 1))-1))
  # Return a mask band image, giving the qa value.
  image$bitwiseAnd(qa)$lt(1)
}

# Usando getQABits construimos una sola variable para la funcion'mod13A2_clean'
mod13A2_clean <- function(img) {
  # Extract the NDVI band
  ndvi_values <- img$select("NDVI")

  # Extract the quality band
  ndvi_qa <- img$select("SummaryQA")

  # Select pixels to mask
  quality_mask <- getQABits(ndvi_qa, "10")

  # Mask pixels with value zero.
  ndvi_values$updateMask(quality_mask)
}

```


#### Filtro del producto NDVI mediante las fechas con mas incendios

```{r, eval=TRUE, message=FALSE, echo = FALSE, warning=FALSE, cache=FALSE}

# La Region de interes es anta, pero puede variar según sigamos el proceso
Anta <- st_read('Materiales/Anta.gpkg')

# Generamos el centroide para la correcta visualizacion
centroid <- st_centroid(Anta)
X <- (st_coordinates(centroid))[,"X"]
Y <- (st_coordinates(centroid))[,"Y"]

ee_roi <- Anta %>%
  st_geometry() %>%
  sf_as_ee()


# Search into the Earth Engine’s public data archive
# ee_search_dataset() %>%
#   ee_search_title("mod13") %>%
#   ee_search_title("1km") %>%
#   ee_search_display()

modis_ndvi <- ee$ImageCollection("MODIS/006/MOD13Q1")


# Creamos un compuesto mensual: para fines de presentacion

ndvi_composite_sc <- modis_ndvi$
  filter(ee$Filter$date('2016-01-01', '2016-12-31'))$
  filter(ee$Filter$calendarRange(1, field = "month"))$
  mean()

ndvi_composite <- modis_ndvi$
  filter(ee$Filter$date('2016-01-01', '2016-12-31'))$
  filter(ee$Filter$calendarRange(1, field = "month"))$
  map(mod13A2_clean)$
  mean()

# Color para el segundo NDVI
ndviParams <- list(palette = c(
  "#d73027", "#f46d43", "#fdae61",
  "#fee08b", "#d9ef8b", "#a6d96a",
  "#66bd63", "#1a9850"
))

# Display results
scale <- 0.0001
Map$setCenter(lon = X, lat = Y, zoom = 10)
Map$addLayer(
  eeObject = ndvi_composite,
  visParams = list(
    min = 0.2 / scale,
    max = 0.7 / scale,
    palette = cpt("grass_ndvi", 10))) + 
  Map$addLayer(ee_roi)
```
Se estuvo trabajando inicialmente con **GEE** con **geemap** en **Python**, pero vimos necesario filtrar según la imagen en **R** con el **rgee**, podemos ver el proceso en [Google Colaboratory](https://colab.research.google.com/drive/12AK2hDrybYn2eNUN0faJwj5qICmIZP4m?authuser=1#scrollTo=kTKeNg7Husn2)

## 6. Resultados

## 7. Análisis 

## 8. Discusión de resultados

## 9. Conclusión

## 10. Referencias


