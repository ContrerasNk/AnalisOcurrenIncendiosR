---
title: "Análisis de las condiciones favorables para la ocurrencia de incendios en el Perú para los años 2000 -2018"
author: "Contreras y Flores"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  pdf_document:
    fig_caption: yes
    latex_engine: xelatex
toc: true
toc_depth: 5
fig_caption: true
mainfont: Times New Roman      
---

# Introducción
Los incendios forestales se han convertido en un problema ambiental de gran relevancia y gravedad en las últimas décadas; se presenta a nivel mundial sobre todo en los países con grandes extensiones de áreas forestales (Sabuco, 2013) como es el caso del Perú (FAO, 2004). 
El impacto de los incendios reduce la tasa de crecimiento de los bosques, genera muerte y migración de la fauna silvestre, pérdida de la biodiversidad, trasformación de los suelos e incremento de la erosión, contaminación del aire, reducción de servicios de regulación hídrica del ecosistema, mayor incidencia en derrumbes e inundaciones, incluso la aparición de plagas y enfermedades en los bosques debilitados por dichos incendios. (MINAM, 2019)
En este análisis se evaluará la estacionalidad de las variables bioclimáticas que favorecen a la ocurrencia de incendios.

## 1. Identificación del problema

En los últimos años los incendios han impactado severamente varias regiones del Perú, como Cusco, Lambayeque, Piura y
Cajamarca (INDECI, 2013; El Comercio, 2018), siendo muy perjudicial para un Perú que no está en condiciones de afrontar este tipo de emergencias al no tener una unidad especializada de respuesta ante Incendios (RPP, 2016). 

### 1.1. Planteamiento del problema
### 1.2. Objetivos
#### 1.2.1. Objetivo General
Analizar la estacionalidad de variables bioclimáticas en el marco del estudio de las condiciones favorables para la ocurrencia de incendios (CFOI).

#### 1.2.2. Objetivos Específicos
* Analizar las variables climáticas (calidad de vegatción, temperatura y preciptación) de forma interestacional en las zonas CFOI
* Analizar el comportamiento estacional de las variables bioclimáticas con respecto a la altitud en las zonas CFOI.

### 1.3. Justificación
Las graves consecuencias que a todos los niveles (ecológico, económico, social y humano) pueden derivarse de un incendio forestal son razones suficientes para dedicar una atención especial a este fenómeno. El hombre ha desarrollado numerosos instrumentos y puesto en práctica diversos procedimientos para combatirlos. 
Este proyecto de investigación se justifica en la carencia de datos estadísticos relacionados al registro histórico de incendios y su distribución espacial, así como su relación con las condiciones favorables que se encuentran presentes en el momento de la aparición del incendio, aspecto que debe ser la base para el entendimiento de este fenómeno y de la generación de las políticas de Estado para atenderlo, desde una óptica de prevención y reducción del riesgo.

## 2. Antecedentes

[MONITOREO DE LAS CONDICIONES FAVORABLES PARA LA OCURRENCIA DE INCENDIOS SOBRE LA COBERTURA VEGETAL – CFOI](https://repositoriodigital.minam.gob.pe/bitstream/handle/123456789/652/Monitoreo-CFOI_CV.pdf?sequence=1&isAllowed=y)

[Ocurrencia de incendios forestales en el Perú durante eventos El Niño](https://repositorio.igp.gob.pe/bitstream/handle/20.500.12816/4704/Zubieta_etal_2019_Ocurrencia-de-incendios-forestales-en-el-Peru-durante-eventos-El-Nino.pdf?sequence=1&isAllowed=y)

[Uso de estimados de densidad Kernell en  la investigación de grupos cerámicos del Periodo Formativo provenientes de Chavín de Huantar](https://revistasinvestigacion.unmsm.edu.pe/index.php/Arqueo/article/view/12339/11039)  


[Estadística no paramétrica I - youtube](https://www.youtube.com/watch?v=Q40ESwQbJO8)  


## 3. Marco Teórico

### 3.1 Función Kernel

* Aveces, el Kernel es una funcion de ventana (window function)
* Una window function fuera de cierto intervalo adopta el valor 0 
* Un kernel, a su vez, es una funcion no negativa (no dijimos qué forma
aun)
* Usaremos un parametro de suavizacion o bandwidth (h) -més alto, mas
suavizamos.

Estimación de la densidad para un punto $x$ :

$${\displaystyle {\widehat {f}}_{h}(x)={\frac {1}{n}}\sum _{i=1}^{n}K_{h}(x-x_{i})={\frac {1}{nh}}\sum _{i=1}^{n}K{\Big (}{\frac {x-x_{i}}{h}}{\Big )}}$$
Donde

* $n:$ Número de observaciones (cada datos es el centro donde se coloca el kernel).
* $h:$ Ancho de banda.
* $K:$ Es la función kernel.


## 4. Área de estudio

## 5. Metodología
Nuestra metodología se resume en cuatro principales etapas, tal y como se describe en la siguiente figura:

```{r echo = FALSE, fig.align='center', comment='Figura 1. Metodología del Trabajo.'}
knitr::include_graphics('Img/metodologia_4etapas.jpg')
```

```{r}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(sf)
library(rgee)
library(mapedit)
library(raster)
library(tmap)
library(cptcity)
library(leaflet)
library(leaflet.extras)
library(MASS)
library(dplyr)
library(tidyverse)
library(rgee)
```

### 5.1 Localización del área de estudio

#### 5.1.1 Histograma de la acumulación de incendios a lo largo del tiempo

```{r}
# Incendios acumulados por mes
shp   <- 'Materiales/registro_incendios_2000_2018.gpkg'
fires <- st_read(shp) %>% 
  mutate(Date = paste(`AñO`, 
                      MES_N, 1, 
                      sep = '-')) %>% 
  group_by(Date) %>% 
  summarise(nfires = length(Date)) %>% 
  mutate(Date = as.Date(Date)) %>%
  arrange(Date) %>% 
  as.data.frame() %>%
  dplyr::select(-geom)
fires
# Como no todos los meses hay incendios se necesita tener todos los meses para generar el histograma
ts    <- data.frame(Date = seq(as.Date('2000-08-01'), 
                               as.Date('2018-12-01'), 
                               by = 'month')) %>% 
  full_join(fires) 
ts

# Generación del histograma

X <- ggplot(ts, aes(x=Date, y=nfires)) + 
  geom_bar(stat="identity", 
           fill="gray", 
           colour="black") +
  theme_bw() + 
  ylab(label = 'Número de incendios\n') +  
  xlab(label = '') + 
  ggtitle(paste('Eventos de incendios \ndel año 2000 al 2018', sep = '')) +
  theme(plot.title = element_text(hjust = 0.5, face = 'bold', size=15),
        axis.text.x  = element_text(size=11, angle = 75, hjust = 1),
        axis.text.y  = element_text(size=11),
        axis.title.y = element_text(size = 12, hjust = 0.5, face = 'bold', vjust = 0.5)) + 
  scale_x_date(limits = c(as.Date('2000-07-01'),
                          as.Date('2019-01-01')),
               date_labels = ("%Y"), 
               breaks = '1 year') +
  scale_y_continuous(breaks = seq(0,500,50))
X
```


#### 5.1.2 Estimación de densidad de probabilidad 2D: función de densidad no paramétrica

Se tratade suvizar una serie tanto en el eje x e y. Seria raro que pase un incendio en un lugar y no haya la probabilidad que ocurra a sus alrededores cercanos, mientras que a unos cuantos metros paso uno grande.

En realidad existe funciones de densidad parámetricas, donde la función depende de la varianza o media muestral, por ejemplo, la función de probabilidad normal.

Se estima la función de densidad de probabilidad para calcular en porcentaje la posibilidad de ocurrencia de incendios para cada pixel, clusterizando las regiones con mayor probabilidad por sobre un umbral definido, además se muestra la región a partir de la cual se basará nuestros graficos de análisis posteriores.

Basicamente, esta función del paquete MASS, la función kernel varía por ubicación (asignandole peso), ese es el porqué de su argumento de coordenadas.




```{r}
fires <- st_read(shp)
peru <- read_sf('Materiales/Peru.gpkg')
Departamentos <- st_read('Materiales/Departamentos.gpkg')

# Extracción de coordenadas de los puntos
fires_df <- st_coordinates(fires) %>% as.data.frame()
names(fires_df) <- c('lon','lat')#here

# Aplicación de la estimación
kde <- kde2d(fires_df$lon, fires_df$lat, n = 250, h = .5, lims = c(-86, -65, -19, 0))
kde_raster <- kde %>% raster() %>% crop(peru) %>% mask(peru)

# image(kde)
# plot(peru, add = T, col = NA)

# Convirtiendolo a raster:
# 
# kde_raster <- kde %>% raster()
# kde_raster[kde_raster < 0.05] = NA
# kde_raster[kde_raster >= 0.05] = 1
# writeRaster(kde_raster, 'raster2.tif')

# summary(kde_raster %>% getValues() %>% as_vector())
# Mapa con leaflet
# pal <- colorNumeric(c("#0C2C84", "#41B6C4", "#FFFFCC"), values(kde_raster ), na.color = "transparent")


pal <- colorNumeric(c("#3182bd", "#fec44f", "#f03b20"), values(kde_raster), na.color ="transparent")
                   

leaflet() %>%
  addTiles() %>%
  addRasterImage(kde_raster, colors = pal) %>%
  addLegend(pal = pal, values = values(kde_raster),title = "% Incendios") %>%
  addPolygons(data = Departamentos,
              fillOpacity = 0,
              weight = 2,
              opacity = 1,
              label = ~DEPARTAMEN,
              color = "#000000",
              group = "Departamentos")
```

#### 5.1.2 Elección del área de estudio

```{r}
Provincias <- st_read('Materiales/Provincias.gpkg')
Anta <- st_read('Materiales/Anta.gpkg')
names(Provincias)
kde_raster_clas <- kde_raster
kde_raster_clas[kde_raster < 0.05] = NA
kde_raster_clas[kde_raster >= 0.05] = 1
# writeRaster(kde_raster, 'raster2.tif')


leaflet() %>%
  addTiles() %>%
  addRasterImage(kde_raster_clas, 
                 colors = "#f03b20") %>%
  # addLegend(pal = pal, values = values(kde_raster),title = "% Incendios") %>%
  addPolygons(data = Provincias,
              fillOpacity = 0,
              weight = 2,
              opacity = 1,
              label = ~PROVINCIA,
              color = "#000000",
              group = "Provincias") %>%
  addPolygons(data = Anta,
              fillOpacity = 0,
              weight = 4,
              opacity = 1,
              label = ~PROVINCIA,
              color = "#54278f",
              group = "Anta")
```


### 5.1 Materiales

#### 5.1.1 Data histórica de incendios 2000-2018
Este registro abarca los años 2000 a 2018, descargados del [geoservidor del Ministerio del Ambiente (MINAM)](https://geoservidor.minam.gob.pe/monitoreo-y-evaluacion/registros-historicos-cfoi/).

#### 5.1.2 Precipitación acumulada y Temperatura Máxima
Este se obtendrá del producto grillado PISCO, del Servicio Nacional de Meteorología e Hidrología (SENHAMI)

#### 5.1.3 Índice de Vegetación Normalizado (NDVI)
Este se obtendrá del producto del sensor MODIS (MOD13Q1) del sensor Terra, 2000 - 2018. Este producto es un compuesto de 16 días, bajo el método de valor máximo, tiene una resolución espacial de 250 m

Ahora toca trabajar con las variables bioclimáticas

```{r , eval=FALSE}
# Inicializando sesion en GEE
ee_Initialize('juliocontreras1', drive =TRUE)
```
Dentro del producto se tiene sub data sets, donde podemos encontrar el NDVI y EVI, y las bandas que se utilizaron para sus calculos, así mismo encontrarás la banda $qa$ o banda de calidad. La banda de calidad (qa) te muestra el estado de los píxeles, según la presencia de artefactos como las nubes, sombras, cobertura de nieve. Aquí filtraremos los datos de NDVI a través de la ***qa*** (0-65535) con una resolución radiométrica de 16 bits $2^16$.

##### Filtro por la banda de calidad
Para entender como se interpreta un banda de calidad no dirigimos a la página de [GRASS GIS](https://grass.osgeo.org/grass78/manuals/i.modis.qc.html), donde nos ofrece un descripción de la ***qa***. Tenemos que pasar nuestros ND de un sistema decimal a uno binario (ahí es donde se hace la interpretación) donde nos resultará 16 dígitos. Los códigos a continuación creará un función filtro **qa**

```{r}
# Filter out poor quality pixels
getQABits <- function(image, qa) {
  # Convert binary (character) to decimal (little endian)
  qa <- sum(2^(which(rev(unlist(strsplit(as.character(qa), "")) == 1))-1))
  # Return a mask band image, giving the qa value.
  image$bitwiseAnd(qa)$lt(1)
}

# Using getQABits we construct a single-argument function 'mod13A2_clean'
mod13A2_clean <- function(img) {
  # Extract the NDVI band
  ndvi_values <- img$select("NDVI")

  # Extract the quality band
  ndvi_qa <- img$select("SummaryQA")

  # Select pixels to mask
  quality_mask <- getQABits(ndvi_qa, "10")

  # Mask pixels with value zero.
  ndvi_values$updateMask(quality_mask)
}

```


#### Filtro del producto NDVI mediante las fechas con mas incendios

```{r}

# La Region de interes es anta, pero puede variar según sigamos el proceso
Anta <- st_read('Materiales/Anta.gpkg')

# Generamos el centroide para la correcta visualizacion
centroid <- st_centroid(Anta)
X <- (st_coordinates(centroid))[,"X"]
Y <- (st_coordinates(centroid))[,"Y"]

ee_roi <- Anta %>%
  st_geometry() %>%
  sf_as_ee()


# Search into the Earth Engine’s public data archive
# ee_search_dataset() %>%
#   ee_search_title("mod13") %>%
#   ee_search_title("1km") %>%
#   ee_search_display()

modis_ndvi <- ee$ImageCollection("MODIS/006/MOD13Q1")


# Creamos un compuesto mensual: para fines de presentacion

ndvi_composite_sc <- modis_ndvi$
  filter(ee$Filter$date('2016-01-01', '2016-12-31'))$
  filter(ee$Filter$calendarRange(1, field = "month"))$
  mean()

ndvi_composite <- modis_ndvi$
  filter(ee$Filter$date('2016-01-01', '2016-12-31'))$
  filter(ee$Filter$calendarRange(1, field = "month"))$
  map(mod13A2_clean)$
  mean()

# Color para el segundo NDVI
ndviParams <- list(palette = c(
  "#d73027", "#f46d43", "#fdae61",
  "#fee08b", "#d9ef8b", "#a6d96a",
  "#66bd63", "#1a9850"
))

# Display results
scale <- 0.0001
Map$setCenter(lon = X, lat = Y, zoom = 10)
Map$addLayer(
  eeObject = ndvi_composite,
  visParams = list(
    min = 0.2 / scale,
    max = 0.7 / scale,
    palette = cpt("grass_ndvi", 10))) + 
  Map$addLayer(ee_roi)
```
Se estuvo trabajando inicialmente con **GEE** con **geemap** en **Python**, pero vimos necesario filtrar según la imagen en **R** con el **rgee**, podemos ver el proceso en [Google Colaboratory](https://colab.research.google.com/drive/12AK2hDrybYn2eNUN0faJwj5qICmIZP4m?authuser=1#scrollTo=kTKeNg7Husn2)

## 6. Resultados

## 7. Análisis 

## 8. Discusión de resultados

## 9. Conclusión

## 10. Referencias


